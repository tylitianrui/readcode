# tsdb
todo : 本章主要讲解`tsdb`   

## 简述

### 时序数据

按照时间顺序记录的数据，就是时序数据，例如某人每顿吃几碗饭、每天的气温、cup使用率等  

例如:两台物理机(a,b)它们的cup使用率
```  
    ^ cpu使用率 
    │ 
    │ 
  a │       10%          12%         10%          6%          50%
    │ 
  b │        6%          8%           12%          8%          3%
    │ 
    └───────────────────────────────────────────────────────────────────>
            12:00        12:01       12:02       12:03        12:04      time

```

机器a、b的`cup使用率`，可以表示成如下形式： 

``` 
  a ->  (12:00, 10%),(12:01, 12%),(12:02, 10%),(12:03, 6%),(12:04, 50%), ......
  b ->  (12:00, 6%), (12:01, 8%), (12:02, 12%),(12:03, 8%),(12:04, 3%) , ......
```


不仅仅是上例。通常情况,时序数据都可使用表示成

```
 identifier  -> (t1,v1),(t2,v2),(t3,v3),(t4,v4), ... 
```  

<br/>

时序数据库特点:  

-  数据以**时间推进**而产生  
- 数据无需更新。 
- 本质是一系列的`K-V`数据`(t,value)`, `key`为时间，`value`就是记录的数据。

<br/>

### prometheus data model
 
**`metric name`与`label`**

格式：
```
<metric name>{<label name>=<label value>, ...} 
```
例如：`prometheus`拉取target的指标时，获取到的原始数据，如下：
```
tyltr_request_total{code="200",method="GET",path="/ping/1"} 1
tyltr_request_total{code="404",method="POST",path="/pingq"} 34
tyltr_request_total{code="404",method="POST",path="/XXXXX"} 5
tyltr_request_total{code="404",method="GET",path="/pingq"} 2
```
说明
-  `metric name`:  `tyltr_request_total`
-  `label`: `code`、`method`、`path`


`prometheus`会将`metric name`与`label`解析成如下格式： 
```
{__name__="tyltr_request_total",code="200",method="GET",path="/ping/1"} 
{__name__="tyltr_request_total",code="404",method="POST",path="/pingq"} 
{__name__="tyltr_request_total",code="404",method="POST",path="/XXXXX"} 
{__name__="tyltr_request_total",code="404",method="GET",path="/pingq"}

```

<details>
  <summary>注: 解析过程</summary>

---
  
   >  ###  函数调用链
   >
   >`func (sl *scrapeLoop) scrapeAndReport(last, appendTime time.Time, errc chan<- error) time.Time `     -->     `func (sl *scrapeLoop) append(app storage.Appender, b []byte, contentType string, ts time.Time) (total, added,    >seriesAdded int, err error) `     -->    **`p.Metric(&lset) ` 解析 metrics 数据**   -->   `lset = sl.sampleMutator(lset)`设置最终的label
   >
   >
   >**p.Metric(&lset)  解析获取到的metrics数据**
   >
   >详见[解析metric](004.scrape.md)

---

</details>

最终，一组指标解析成下面的数据： 

```
{ __name__="tyltr_request_total", instance="127.0.0.1:9100", job="prom_target",code="200",method="GET",path="/ping/1"}    1711809974984          1
{ __name__="tyltr_request_total", instance="127.0.0.1:9100", job="prom_target",code="404",method="POST",path="/pingq"}    1711810012158         34
{ __name__="tyltr_request_total", instance="127.0.0.1:9100", job="prom_target",code="404",method="POST",path="/XXXXX"}    1711810012158          5
{ __name__="tyltr_request_total", instance="127.0.0.1:9100", job="prom_target",code="404",method="GET",path="/pingq" }    1711810032980          2

 |_____________________________|  |_________________________________________________________________________________|     |___________|        |___|                 prometheus 数据
        metric name                                                lables                                                    timestamp       sample value
 |__________________________________________________________________________________________________________________|     |___________|                               time-series 
                                                 一些列的series                                                                时间

 |_____________________________________________________________________________________________________________________________________|       |___|                  时序数据的抽象k-v结果      
                                      带有时间属性的key                                                                                           value

```
<br/>  

**强调:什么是series?**

**series** 指的是`metric_name + labels `构成的"标识",而单单是一类指标metric。例如上例:   
1. 下面四个:
  - `{__name__="tyltr_request_total",instance="127.0.0.1:9100",job="prom_target",code="200",method="GET",path="/ping/1"} `
  - `{__name__="tyltr_request_total",instance="127.0.0.1:9100",job="prom_target",code="404",method="POST",path="/pingq"} `
  - `{__name__="tyltr_request_total",instance="127.0.0.1:9100",job="prom_target",code="404",method="POST",path="/XXXXX"}`
  - `{__name__="tyltr_request_total",instance="127.0.0.1:9100",job="prom_target",code="404",method="GET",path="/pingq" }`  
都属不同**series**
1. 上述四个的**series**都属于 `__name__="tyltr_request_total"`的指标数据  


上述的监控指标，通过二维坐标(*x 轴是时间，y轴是序列series*)可以表示成 

```                                                                                                                     
                                                                                                                         ^  series
                                                                                                                         │  
{ __name__="tyltr_request_total", instance="127.0.0.1:9100", job="prom_target",code="200",method="GET",path="/ping/1"}   │          1                 .                                                  .             .
                                                                                                                         │             
{ __name__="tyltr_request_total", instance="127.0.0.1:9100", job="prom_target",code="404",method="POST",path="/pingq"}   │          .                 34                  .               .                           
                                                                                                                         │            
{ __name__="tyltr_request_total", instance="127.0.0.1:9100", job="prom_target",code="404",method="POST",path="/XXXXX"}   │          .                 5                   .               .               .             . 
                                                                                                                         │             
{ __name__="tyltr_request_total", instance="127.0.0.1:9100", job="prom_target",code="404",method="GET",path="/pingq" }   │          .                 .                   2                                           
                                                                                                                         │             
                                                                                                                         └── ~ ───────────────────────────────────────────────────────────────────────────────────────────────────>
                                                                                                                              1711809974984        1711810012158       1711810032980      ..             ..             ..     timestamp


```
## 时序数据库简述

**时序数据库应用场景**   
- **监控**,例如系统监控、设备监控等
- **数据分析**，例如股票、外汇等金融交易等；气温气候检测等  

<br/>

**时序数据库特点**   

- 只有**写**和**读**操作，没有更新操作。
- 实际应用中，**多读写少** 
- 大量的**统计、聚合**查询
- 一般情况，新数据查询多，老数据查询少。**新热老冷** <!-- 涉及到历史数据的处理问题  -->  

<br/>

<!-- 
**历史数据的处理策略**

一般情况，时序数据库中新数据查询多，老数据查询少(**新热老冷** )。如何处理很少被用到的历史数据，是所有时序数据库必须解决的问题。 

 -->  




## `TSDB V2`简述

`prometheus TSDB`经历了两个主要的版本:  
- `prometheus v1.x`使用`TSDB V2`版本
- `prometheus v2.x`使用`TSDB V3`版本

本节说明一下`TSDB V2`版本

**`TSDB V2`特性**  

- **每一个`serie`分别存放到不同的,独立的文件中**
   > 例如: 上例中四个`serie`会各种存放在四个独立的文件中。例如:
   >   - `{__name__="tyltr_request_total",instance="127.0.0.1:9100",job="prom_target",code="200",method="GET",path="/ping/1"} ` 存储于文件a
   >   - `{__name__="tyltr_request_total",instance="127.0.0.1:9100",job="prom_target",code="404",method="POST",path="/pingq"} ` 存储于文件b
   >   - `{__name__="tyltr_request_total",instance="127.0.0.1:9100",job="prom_target",code="404",method="POST",path="/XXXXX"}`  存储于文件c
   >   - `{__name__="tyltr_request_total",instance="127.0.0.1:9100",job="prom_target",code="404",method="GET",path="/pingq" }`  存储于文件d  
   >  
  也就是说`TSDB V2`存在大量的文件，读写时需要保持大量文件处于打开状态,**容易触发系统最大打开文件数**



  <details>
    <summary>引申: linux系统最大打开文件数</summary>  

     - 查看**系统**允许打开的最大文件数
        > ```
        > sysctl fs.file-max
        > ```

    - 查看**进程**允许打开的最大文件数
        >```
        > ulimit -n
        > ```
 
 
    -  执行如下命令
     
       > ```
       >   ubuntu~$  sysctl fs.file-max
       >   fs.file-max = 6815744
       >   
       >   ubuntu~$  ulimit -n
       >   1024
       > ```
     
       > **疑问:为什么执行数据不一致呢？**
     
       > - `sysctl fs.file-max`：表示**系统**的能够打开的文件的数量。是对**整个系统**的限制，并不是针对用户进程的。
       >  - `ulimit -n`：标识**进程**能够打开的文件的数量，例如nginx可以打开的最多文件句柄
  </details>


  <br/>

- **`time series`的最新数据都会缓存到内存，然后批量落盘**
  > 每一个`time series`对应内存中的独立的`chunk(1KiB)`，没有`WAL`,机器宕机，存储在内存的数据就会丢失
  <br/>
- **随机读写**
  > 每个文件是顺序批量写，但`tsdb v2`会读写大量的文件，就会产生随机读写的问题。
  <br/>
- **不适应云原生环境**
  > 在云原生环境中，应用服务的生命周期是短暂的。**随时**都可能"迁移"到其他的`node`上,那么地址就会发生变化，原本的时序就消失了并产生新的时序,`tsdb v2`每个时序就是一个文件，所以就会**创建新的文件**存储相应的指标数据。那么系统里就会出现大量的小而碎的文件。并且需要在大量的时序中查找数据，性能就很差了。
  <br/>
- **写放大的问题** 
  > 虽然为了节约内存，将`chunk`限制为`1KiB`。但如果是`SSD`硬盘,就可能导致**写放大**问题

  <details>
    <summary>引申: SSD的写放大</summary> 

---  
  todo
    
---
  </details>


## `TSDB V3`

由于`TSDB V2`版本面临上述的诸多问题，`TSDB V3`应运而生。目前`prometheus v2.x`使用就是`TSDB V3`。本章的重点就是阐述`TSDB V3`

TODO